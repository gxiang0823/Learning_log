## Linux知识与UNIX Shell编程

### 常用命令行

在Linux中，`xargs`、`sed` 和 `awk` 是三个非常强大的命令行工具，它们在处理文本数据时发挥着重要作用。下面我将分别介绍这三个工具的基本用法。

#### xargs
`xargs` 是一个从标准输入构建和执行命令行的实用程序。它通常与管道（`|`）一起使用，以便将前一个命令的输出作为参数传递给下一个命令。
**基本语法：**
```bash
command1 | xargs command2
```
**常用选项：**
- `-I{}`：指定替换字符串。
- `-n`：指定每次执行命令时的最大参数数量。
- `-P`：指定并行执行的进程数。
**示例：**
```bash
# 将文件名传递给 cat 命令
ls | xargs cat
# 使用 -I{} 替换字符串
echo "file1.txt file2.txt" | xargs -I{} cp {} backup/
# 每次执行命令时最多处理两个参数，并行执行 3 个进程
find . -name "*.log" | xargs -n 2 -P 3 grep "error"
```
#### sed
`sed` 是一个流编辑器，用于基本的文本转换。它可以对输入的数据进行搜索、替换、删除和插入操作。
**基本语法：**
```bash
sed [选项] '命令' 文件名
```
**常用选项：**
- `-n`：不自动打印模式空间。
- `-e`：指定多个脚本。
- `-i`：直接在文件中进行编辑（可选备份）。
**示例：**
```bash
# 替换文本
sed 's/old_text/new_text/g' file.txt
# 删除行
sed '/pattern/d' file.txt
# 插入行
sed '1i\
new line at the beginning' file.txt
# 使用 -n 和 -e 选项
sed -ne '1,5p' file.txt
```

#### awk
`awk` 是一个强大的文本处理工具，可以进行复杂的模式匹配和数据处理。它通常用于从文件中提取特定的字段或行。
**基本语法：**
```bash
awk [选项] '脚本' 文件名
```
**常用选项：**
- `-F`：指定输入字段分隔符。
- `-v`：定义变量。
**示例：**
```bash
# 打印第一列和第三列
awk '{print $1, $3}' file.txt
# 使用 -F 指定字段分隔符
awk -F: '{print $1, $7}' /etc/passwd
# 定义变量
awk -v sum=0 'BEGIN {for(i=1;i<=5;i++) sum+=i; print sum}'
# 处理多行数据
awk '/start/,/end/' file.txt
```
这三个工具在Linux中非常强大，它们可以单独使用也可以结合使用，以实现复杂的文本处理任务。熟练掌握这些工具的用法将大大提高你的命令行工作效率。

### vim常用命令
Vim 是一个功能强大的文本编辑器，广泛应用于 Unix 和类 Unix 系统上。以下是一些常用的 Vim 操作指令：

#### 1. 进入和退出 Vim

- **启动 Vim**：
```Bash
vim 文件名
```

- **进入插入模式（Insert Mode）**：
- `i`：在当前光标前插入文本。
- `I`：在行首插入文本。
- `a`：在当前光标后插入文本。
- `A`：在行尾插入文本。
- `o`：在当前行下方插入一个新行并进入插入模式。
- `O`：在当前行上方插入一个新行并进入插入模式。

- **退出插入模式**：
- 按下 `Esc` 键返回到正常模式（Normal Mode）。

- **保存并退出**：
- `:wq` 或 `ZZ`

- **强制退出而不保存**：
- `:q!` 或 `ZQ`

#### 2. 移动光标

- **上下左右移动**：
- `h`：左移一个字符。
- `j`：下移一行。
- `k`：上移一行。
- `l`：右移一个字符。

- **跳转到行首和行尾**：
- `0`：跳转到当前行的行首。
- `$`：跳转到当前行的行尾。

- **跳转到文件开头和结尾**：
- `gg`：跳转到文件开头。
- `G`：跳转到文件结尾。

- **跳转到指定行**：
- `:n`（其中 n 是行号）：跳转到第 n 行。

#### 3. 删除字符和行

- **删除单个字符**：
- `x`：删除光标后的字符。
- `X`：删除光标前的字符。
- `dl`：与 `x` 功能相同，删除光标后的字符。
- `dh`：与 `X` 功能相同，删除光标前的字符。

- **删除整行**：
- `dd`：删除当前行。
- `d0` 或 `d^`：删除从光标位置到行首的所有字符（包括空格）。
- `d$`：删除从光标位置到行尾的所有字符。
- `dG`：删除从当前行到文件结尾的所有内容。

- **删除多行**：
- `5dd`：删除接下来的 5 行。
- `dgg`：删除从当前行到文件开头的所有内容。
- `dG`：删除从当前行到文件结尾的所有内容。

#### 4. 复制和粘贴

- **复制（Yank）**：
- `yy`：复制当前行。
- `y$`：复制从光标位置到行尾的文本。
- `y0` 或 `y^`：复制从光标位置到行首的文本（包括空格）。

- **粘贴（Paste）**：
- `p`：在光标后粘贴内容。
- `P`：在光标前粘贴内容。

#### 5. 撤销和重做

- **撤销上一次操作**：
- `u`

- **重做最后一次撤销的操作**：
- `Ctrl + r`

#### 6. 查找和替换

- **查找文本**：
- `/pattern`：在文件中向下搜索指定的模式。
- `?pattern`：在文件中向上搜索指定的模式。

- **查找下一个/上一个匹配项**：
- `n`：查找下一个匹配项。
- `N`：查找上一个匹配项。

- **替换文本**：
- `:s/旧字符串/新字符串/`：替换当前行的第一个匹配项。
- `:%s/旧字符串/新字符串/g`：全局替换文件中所有匹配项（即在整文件范围内）。

#### 7. 其他常用命令

- **删除到行尾**：
- `D`

- **删除到行首**：
- `d0` 或 `d^`

- **复制当前行**：
- `yy` 或 `Y`

- **粘贴到当前行后**：
- `p`

- **粘贴到当前行前**：
- `P`

#### 8. 缩进

- **增加缩进**：
- `>>`

- **减少缩进**：
- `<<`

#### 9. 查看和设置配置

- **查看当前配置**：
- `:set` 或 `:set all`

- **开启行号显示**：
- `:set number` 或简写为 `:set nu`

- **关闭行号显示**：
- `:set nonumber` 或简写为 `:set nnu`

#### 10. 插入多行文本

在插入模式下，可以使用以下快捷键来复制和粘贴多行文本：

- **复制当前行**：
- `yy`

- **切换到普通模式**：
- 按下 `Esc` 键

- **粘贴到光标后**：
- `p`

### 查看线程和进程
在 Linux 系统中，查看多进程和多线程程序的核心工具围绕 **`ps`、`top`、`pstree`、`htop`** 等，其中多线程的查看需要针对 Linux 中“线程=轻量级进程（LWP）”的特性，使用特定参数过滤。以下是分场景的详细方法，包含命令、参数解释和实战示例：


#### 一、查看多进程程序
进程是操作系统资源分配的基本单位，每个进程有独立的 PID（进程 ID）。核心工具是 `ps`（静态查看）、`top`（实时监控）、`pstree`（树状层级）。

1.  静态查看所有进程（`ps` 命令）
`ps` 是最基础的进程查看工具，常用参数组合可覆盖绝大多数场景：
```bash
# 1. 查看系统所有进程（全格式、包含命令行）
ps aux

# 2. 查看进程的父-child 关系（PPID=父进程ID，PID=子进程ID）
ps -ef

# 3. 过滤特定程序的进程（例如查看 Python 程序的所有进程）
ps aux | grep python
ps -ef | grep java
```
2.  输出字段关键含义：

| 字段       | 说明                          |
|------------|-----------------------------|
| `PID`      | 进程唯一 ID（核心标识）       |
| `PPID`     | 父进程 ID（查看进程层级用）    |
| `%CPU`     | 进程占用的 CPU 百分比         |
| `%MEM`     | 进程占用的内存百分比          |
| `USER`     | 进程所属用户                 |
| `COMMAND`  | 启动进程的命令（含参数）      |

-   示例：查看 Nginx 多进程（Nginx 默认是多进程模型）
    ```bash
    ps aux | grep nginx
    ```
    输出可能如下（`nginx: master process` 是主进程，`nginx: worker process` 是工作进程，即多进程）：
    ```
    root      1234  0.0  0.1  12340  2340 ?        Ss   10:00   0:00 nginx: master process /usr/sbin/nginx
    www-data  1235  0.2  0.3  12560  4560 ?        S    10:00   0:05 nginx: worker process
    www-data  1236  0.1  0.3  12560  4520 ?        S    10:00   0:03 nginx: worker process
    ```


3.  实时监控进程（`top` 命令）
`top` 是实时交互工具，默认每 3 秒刷新一次，适合观察进程资源占用变化：
```bash
# 启动实时监控
top

# 关键交互快捷键（启动后按）
P：按 CPU 使用率排序（默认）
M：按内存使用率排序
N：按 PID 排序
u：过滤指定用户的进程（例如输入 root 只看 root 进程）
p：过滤指定 PID 的进程（例如输入 1234 只看 PID=1234 的进程）
q：退出 top
```
-   示例：实时观察 Python 多进程程序的 CPU/内存占用
    启动 `top` 后按 `u`，输入运行 Python 程序的用户名（如 `ubuntu`），即可只显示该用户的 Python 进程。


4.  树状查看进程层级（`pstree` 命令）
`pstree` 以树状结构展示进程的父-child 关系，适合快速查看多进程的衍生关系（例如主进程 fork 出的子进程）：
```bash
# 查看所有进程的树状结构（PID 显示在括号中）
pstree -p

# 过滤特定进程的树状结构（例如查看 PID=1234 的进程及其子进程）
pstree -p 1234

# 查看指定用户的进程树
pstree -u ubuntu
```
-   示例：查看 Nginx 进程树（主进程 + 工作进程）
    ```bash
    pstree -p | grep nginx
    ```
    输出：
    ```
    nginx(1234)───nginx(1235)
                └──nginx(1236)
    ```


#### 二、查看多线程程序
Linux 中线程被称为“轻量级进程（LWP）”，共享进程的地址空间，每个线程有独立的 LWP（线程 ID），但共享同一个 PID（进程 ID）。查看多线程的核心是：**显示进程下的所有 LWP**。

1.  用 `ps` 查看指定进程的所有线程
```bash
# 1. 查看所有线程（H：线程模式，显示每个线程为独立行）
ps auxH

# 2. 查看指定进程的所有线程（L：显示 LWP 线程ID，p：指定 PID）
ps -Lp <进程PID>

# 3. 详细显示线程信息（包含线程状态、优先级）
ps -mp <进程PID> -o PID,PPID,LWP,NLWP,PCPU,STAT,COMMAND
```
输出字段关键含义：

| 字段 | 说明 |
|-----|-----|
| `LWP` | 线程 ID（核心标识）|
| `NLWP` | 进程的总线程数 |
| `STAT` | 线程状态（R=运行，S=睡眠等）|

-   示例：查看 Python 多线程程序（PID=5678）的所有线程
    ```bash
    # 先找到 Python 程序的 PID
    ps aux | grep python  # 假设 PID=5678

    # 查看该进程的所有线程
    ps -Lp 5678
    ```
    输出（`LWP` 不同的行就是不同线程，`PID` 相同）：
    ```
    PID   LWP TTY          TIME CMD
    5678  5678 pts/0    00:00:00 python
    5678  5679 pts/0    00:00:01 python
    5678  5680 pts/0    00:00:01 python
    ```


1.  用 `top` 实时监控线程
`top` 加 `-H` 参数可进入“线程模式”，将每个线程当作独立条目显示，方便观察线程的资源占用：
```bash
# 1. 实时监控所有线程（H：线程模式）
top -H

# 2. 实时监控指定进程的所有线程（Hp：指定 PID，只看该进程的线程）
top -Hp <进程PID>
```
-   交互快捷键（同 `top`）：
    -   `P`：按线程 CPU 使用率排序（快速找到最耗 CPU 的线程）
    -   `M`：按线程内存使用率排序
    -   `q`：退出

-   示例：监控 Java 多线程程序（PID=9012）的线程
    ```bash
    top -Hp 9012
    ```
    输出中，`PID` 列实际显示的是 `LWP`（线程 ID），`COMMAND` 列显示线程所属的进程名，可快速定位高负载线程。


3.  用 `htop` 可视化查看线程（推荐）
`htop` 是 `top` 的增强版，界面更友好，支持线程的树状显示和快速切换，需手动安装（`yum install htop` 或 `apt install htop`）：
```bash
# 启动 htop
htop

# 关键快捷键
F2 → Display options → 勾选 "Tree view"（树状显示进程/线程）
F2 → Display options → 勾选 "Show threads"（显示线程）
H：切换“显示/隐藏线程”（按 H 一次显示所有线程，再按一次隐藏）
P：按 CPU 排序，M：按内存排序
```
-   优势：
    -   线程以缩进形式显示在父进程下（树状结构），一目了然
    -   支持鼠标操作，可直接点击进程展开/折叠线程
    -   显示线程数（`THR` 列），快速判断进程是否为多线程


4.  从 `/proc` 文件系统查看线程（底层方式）
Linux 每个进程的信息都存储在 `/proc/<PID>` 目录下，线程对应的目录是 `/proc/<PID>/task/<LWP>`（每个 LWP 对应一个子目录）：
```bash
# 1. 查看指定进程的总线程数
cat /proc/<进程PID>/status | grep Threads

# 2. 查看指定进程的所有线程 ID（LWP）
ls /proc/<进程PID>/task/

# 3. 查看某个线程的详细信息（例如 LWP=5679）
cat /proc/<进程PID>/task/<LWP>/status
```
-   示例：查看 PID=5678 的进程的线程数和线程 ID
    ```bash
    # 总线程数
    cat /proc/5678/status | grep Threads
    # 输出：Threads:	3（表示 3 个线程）

    # 所有线程 ID（LWP）
    ls /proc/5678/task/
    # 输出：5678  5679  5680（3 个线程的 LWP）
    ```


#### 三、关键区别：多进程 vs 多线程的查看特征
| 维度 | 多进程程序 | 多线程程序 |
|-----|-----|-----|
| PID | 每个进程有独立 PID | 所有线程共享同一个 PID |
| LWP | 每个进程的 LWP = 自身 PID | 每个线程有独立 LWP（≠ PID）|
| `ps` 查看 | `ps aux` 显示多个独立 PID | `ps -Lp <PID>` 显示多个 LWP |
| `top` 查看 | 多个独立条目（不同 PID）| `top -Hp <PID>` 显示多个条目（不同 LWP）|
| `/proc` 目录 | 每个进程对应 `/proc/<PID>` | 所有线程对应 `/proc/<PID>/task/<LWP>` |


#### 四、常用场景总结
| 需求 | 推荐命令 |
|-----|-----|
| 快速查看系统所有多进程 | `ps aux` 或 `top` |
| 查看进程的父子关系 | `pstree -p` 或 `ps -ef` |
| 查看指定程序的所有线程 | `ps -Lp <PID>` 或 `htop`（按 H 显示线程）|
| 实时监控线程的 CPU/内存占用 | `top -Hp <PID>` 或 `htop` |
| 验证进程是否为多线程 | `cat /proc/<PID>/status | grep Threads` |
| 可视化查看线程结构 | `htop`（树状模式）|


## 正则表达式
[学习正则表达式](assets/pdfs/学习正则表达式.pdf)
### 常用对应表


含义-字符
| 含义 | 字符 | 含义 | 字符 |
|-----|-----|-----|-----|
|数字|\d|非数字|\D|
|单词字符-数字、字母、下划线|\w|非单词字符|\W|
|报警符|\a|通配符|.|
|退格字符|[\b]|控制字符|\c x|
|空字符|\0|字符的八进制|\o xxx|
|字符的十六进制|\x xx|字符的Unicode值|\u xxx|
|空白符|\s|非空白符|\S|
|制表符|\t|换行符|\n|
|回车符|\r|换页符|\f|
|水平空白符|\h|非水平空白符|\H|
|垂直制表符|\v|非垂直制表符|\V|
|零个或一个|?|一个或多个|+|
|任意个|*|||

### 量词-贪心量词
1. 使用花括号可以限制某个模式在某个范围内匹配的次数，未经修饰的量词就是贪心量词。
- 例如，7{1} 匹配第一次出现的7。7{1,} 匹配一个多个数字7。
- 例如，7{0,} 匹配零个或多个数字7。
- 还可以匹配m到n次，比如：7{3,5} 匹配三个、四个以及五个7。

| 语法 | 描述 |
|-----|-----|
|{n}|精确匹配n次|
|{n,}|匹配n次或更多次|
|{m,n}|匹配m至n次|
|{0,1}|与?相同(零次或一次)|
|{1,}|与+相同(一次或更多)|
|{0,}|与*相同(零次或更多)|

### 量词-懒惰量词
1. 贪心量词再加上一个?就能使量词变为懒惰的。
- 例如，5?? 它不会匹配任何内容，该模式已经是懒惰的了。
2. 懒惰的基本特性就是匹配尽可能少的字符。
- 例如，5*? 它也不会匹配任何内容，因为它可以选字匹配最少的次数——零次。

| 语法 | 描述 |
|-----|-----|
|??|懒惰匹配零次或一次(可选)|
|+?|懒惰匹配一次或多次|
|*?|懒惰匹配零次或多次|
|{n}?|懒惰匹配n次|
|{n,}?|懒惰匹配n次或多次|
|{m,n}?|懒惰匹配m至n次|
### 量词-占有量词
1. 占有式匹配很像贪心式匹配，它选定会尽可能多的内容。但与贪心式匹配不同的是它不进行回溯。
2. 他不会放弃做找到的内容。用+匹配。

| 语法 | 描述 |
|-----|-----|
|?+|占有式匹配零次或一次(可选)|
|++|占有式匹配一次或多次|
|*+|占有式匹配零次或多次|
|{n}+|占有式匹配n次|
|{n,}+|占有式匹配n次或多次|
|{m,n}+|占有式匹配m至n次|
### 边界-行的起始与结束
1. 脱字符：^ 匹配行或者字符串的起始。美元符：$ 匹配行或者字符串的结尾位置。
- 例如，^How.*Country\.$ 这个正则表达式，会匹配以How开头，以Country结尾的整行。
- 注意：结尾的点号之前有一个反斜杠，它对点号进行转义，这样点号就被解释为字面值。

### 边界-单词边界与非单词边界
1. \b 用来匹配单词边界。例如，\bTHE\b 会匹配THE单词。
- \b是个零宽度断言，类似于^和$，表面上它会匹配空格或行起始，而实际上它匹配的是个零宽度的不存在的东西。
- 比如它匹配THE时，THE两边的空格是没有被标亮的。
2. \B 匹配非单词边界。它匹配的字符两边都是其他字母或非单词字符。
- 注意，字母、数字、下划线算作单词字符，及\b不会将字母、数字、下划线看作单词边界。
3. 旧语法中使用 \<指定单词的开头，用\>指定单词的结尾。
- 在Notepad++中搜索\>会找到单词的结尾，搜索\<会找到单词的开头。
- linux中配合grep也可以搜索。例如：grep -Eoc '\<(THE|The|the)\>' test.txt
- -E表示使用扩展的正则表达式。-o表示结果只显示一行中与模式相匹配的部分。-c表示只返回结果数量。
### 边界-其他锚位符
1. 没看懂？？？疑问留存
### 边界-元字符的字面值
1. 元字符共有15个：.^$*+?|(){}[]\\-
- 这15个字符用来编写匹配模式，如果尝试匹配文本中的这些字符，用他们是没有结果的。
- 可以使用\Q和\E 字符。它们之间的任意字符都会被解释为普通字符。例如：\Q$\E
- 也可以在元字符前加一个\使其匹配字面值。

## gdb调试
### 1. 启动调试
在`/Restore/bin`目录下`gdb ./Restore`启动调试
启动前最好先`source ./profile`一下
### 2. 打断点
- 在某个函数处打断点：
```Bash
b WebScoketModuleKKKey::Process
```
- 在某个CPP文件某一行大短短：
```Bash
b dpi_wshandle_extractor.cpp:2044
```
- 在某个cpp里时可以直接将断点打成行号
### 3. 常用命令

|命令|作用|备注|
|-----|-----|-----|
|`q`|退出gdb调试|quit|
|`c`|继续运行调试|continue|
|`s`|执行下一步，跳转|step|
|`n`|执行下一步，不跳转|next|
|`r`|运行调试|run，需要空格后跟参数信息|
|`i b`|查看断点信息|info break|
|`d xxx`|删除断点|delete，xxx位断点号，可用5-9批量删除|
|`i locals`|查看局部变量信息|info locals|
|`p/x *data@len`|以16进制格式打印||
|`x/16xb frame`|按HEX格式查看16位frame的值||
|`display xxxxx`|每次命令显示xxxxx的值||
|`bt`|查看堆栈|backtrace(段错误排查)|
|`until xxx`|运行直到某一行，xxx填行数||

### 4. 放包调试，开启两个连接，
- 第一个连接，找到RestoreOther进程的进程号，然后用命令`gdb -p [进程号]`
- 然后和读包一样b打断点，然后c继续执行
- 然后在另一台机器上执行放包命令

## Git
### 仓库配置
- 先在编译环境上生成机器公钥
```Bash
ssh-keygen -t rsa -C "zhangsan-linux"
```
生成的秘钥在`cat ~/.ssh/id_rsa.pub`路径下
- 将生成的秘钥拷贝到GitLab的SSH Key页
- 配置个人信息
```Bash
git config user.name 张三
git config user.email qwer@asdfghjkl.com
```
- 连接远程仓库，拉取代码
```Bash
git clone git@fh-gitlab.asdfghjkl.com:qwer/prv-8-analyzers-szhang.git # 克隆个人远程仓库
git remote add product git@fh-gitlab.asdfghjkl.com:pr/prv8/prv8-analyzers.git # 将产品仓库也添加为远程仓库，别名为product。
```
- 查看状态
```Bash
git remote -v # 查看远程仓库信息
git status # 检查发生变化的文件是否符合预期
```

### 查看状态
- 显示工作目录和暂存区与最近一次提交之间的差异
```Bash
git status
```
- 进行rebase时
[解决修改提交信息，即rebase状态](#解决修改提交信息，即rebase状态)
- 有未推送到远程的本地提交/领先一个提交
- 解决：
1. 将本地提交推送到远程`git push origin master`
2. 用远程仓库状态同步本地仓库`git pull origin master`

### 查看分支
- ```Bash
git branch # 显示所有 本地分支
git branch -r # 显示所有 远程跟踪分支（即远程仓库中的分支）
git branch -a # 显示所有 本地分支 和 远程跟踪分支
```

### 切换分支
- ```Bash
git checkout master # 切换到名为 master 的分支,并更新文件
git checkout -b # 创建并切换到新分支
git checkout origin/ # 切换到远程分支
```
- 具体作用：
1. 切换分支：将当前工作目录从当前所在的分支切换到`master`分支。
2. 更新文件：如果`master`分支的最新提交与你当前的工作区不同，Git会自动更新工作区中的文件以匹配`master`分支的内容。
- **无冲突情况**
表示你已经成功切换到`master`分支。且你的本地`master`分支与远程仓库的`origin/master`分支是同步的，没有任何未合并或未推送的更改。
- **分支落后情况**

- **有冲突情况**
[解决切换分支过程中遇到的未跟踪文件冲突问题](#解决切换分支过程中遇到的未跟踪文件冲突问题)


### 删除分支
- 删除本地分支
```Bash
git branch -d [branch-name] # 删除本地分支
git branch -D [branch-name] # 强制删除本地分支
```
- 删除远程分支
```Bash
git push origin -d [branch-name] # 删除远程分支
```
- 更新远程分支到本地引用
```Bash
git fetch -p # 从远程仓库获取更新并删除本地不再存在的远程分支
git fetch --prune # 同上
```

### 获取更新
- 基本用法
```Bash
git pull # 从当前分支对应的远程仓库获取最新更改，并尝试合并到当前分支
```
- 指定远程仓库和分支
```Bash
git pull [remote] [branch] # 从远程仓库的分支获取最新更改，并尝试合并到当前分支
```
**正常获取更新显示**
**用`git reset`回退后拉取有冲突**
[解决回退后获取更新有冲突](#解决回退后获取更新有冲突)
- 指定拉取策略
```Bash
git pull --rebase # 使用 git rebase 而不是 git merge 来应用远程分支的更改。这可以保持提交历史的线性。
```
- 忽略本地更改并强制拉取
```Bash
git pull --ff-only # 只会尝试进行快进合并（fast-forward merge），如果当前分支无法通过快进合并到远程分支，则会失败。
```
### 解决个人远程、产品远程和个人本地三端不同步问题↑↑↑
- `git`产品远程仓库和个人远程仓库不同步：
```Bash
# 步骤1：确保远程仓库配置正确
git remote -v
# 步骤2：获取最新提交、分支和标签信息
git fetch product
# 步骤3：检查是否有更新
git status
git log
# 步骤4：如果显示有提交差异，执行同步
git checkout master
# 步骤5：选择以以下一种方式同步
# 方式A - 合并（保留你的本地提交）
git merge product/master
# 方式B - 重置（完全匹配产品仓库）
git reset --hard product/master
# 方式C - 变基（整洁的历史线）
git rebase product/master
# 此时你的个人本地至少和产品远程一样，或者领先产品远程
# 推送到个人远程仓库
git push --force origin master
```

### 解决修改提交信息，即rebase状态↑↑↑


如果Git 提示你正在编辑一个提交（commit），并且要求你使用 git commit --amend 来修改当前的提交，或者使用 git rebase --continue 继续操作。参考下文：
1. 理解当前状态
```Bash
git status
```
2. 使用`git commit --amend`修改当前提交
```Bash
# 编辑提交消息
git commit --amend
# 或者直接在命令行中修改提交消息
git commit --amend -m "新的提交消息"
```
如果你想要添加或修改文件内容并将其包含在当前提交中，可以在编辑完文件后再次运行`git commit --amend`
3. 使用`git rebase --continue`继续操作
如果你已经完成了对当前提交的修改，并且满意当前的内容，可以继续`rebase`操作
```Bash
git rebase --continue
```
这会将`rebase`进程继续到下一个步骤。
4. 解决冲突并继续（如果有冲突）
5. 放弃当前`rebase`操作
如果你决定放弃当前的`rebase`操作，并恢复到之前的分支状态，可以使用以下命令：
```Bash
git rebase --abort
```

### 解决`git reset`回退后`git pull`获取更新有冲突↑↑↑


在本地使用 git reset 回退到某个提交后，如果希望将这个更改同步到远程仓库（即让远程仓库也回退到相同的提交），你需要执行以下步骤：
1. 回退到某个特定的提交
```Bash
# 查看提交历史，找到目标提交的哈希值
git log

# 回退到指定提交并重置工作目录和暂存区
git reset 2040725b1abae94fa3cd3e71342a9b147ebd9c47
```
2. 删除本地文件(可选)
3. 强制推送回退后的本地分支
```Bash
git push origin main --force
```

### 解决切换分支过程中遇到的未跟踪文件冲突↑↑↑


- 原因：在尝试切换到`master`分支时，有一些未跟踪的文件（untracked files）会与目标分支中的同名文件冲突。具体来说，`test.txt`文件在当前分支中存在且未被 Git 跟踪，但在`master`分支中也有这个文件。
- 解决方法：
1. 删除未跟踪的文件
如果确定`test.txt`不再需要，可以将其删除，然后切换分支。
```Bash
rm test.txt
git checkout master
```
2. 移动或重命名未跟踪的文件
如果希望保留 test.txt 文件，但不想在切换分支时与同名文件冲突，可以先将其移动到其他位置或重命名，然后再切换分支。
```Bash
mv test.txt test-old.txt
git checkout master
```
3. 使用`-f`或`--force`选项强制切换分支
如果确定要覆盖未跟踪的文件，可以使用`-f`或`--force`选项强制切换分支。但请注意，这会直接删除未跟踪的文件。
```Bash
git checkout -f master
```
4. 添加到暂存区后再切换分支
可以将未跟踪的文件添加到暂存区（即开始跟踪），然后再进行分支切换。这样可以避免冲突。
```Bash
git add test.txt
git commit -m "Add untracked file for safekeeping"
git checkout master
```
5. 使用`git clean`命令清理未跟踪的文件
如果有多个未跟踪的文件，可以使用 git clean 命令一次性清理这些文件。-n 选项用于查看将要删除的文件列表。
```Bash
git clean -n
# 确认无误后，执行以下命令进行实际删除
git clean -f
git checkout master
```

### `git fetch`和`git pull`区别
- `git fetch`:
- 功能: 获取远程仓库的最新更改，但不会自动合并到当前分支。
- 目的: 更新本地对远程仓库状态的认识，而不影响工作目录中的内容。
- `git pull`:
- 功能: 获取远程仓库的最新更改，并尝试将这些更改合并到当前分支。
- 目的: 将远程分支的更新自动应用到本地分支，确保工作目录与远程仓库同步。
- `git fetch`:
1. 获取远程更新: 从指定的远程仓库下载**最新的提交、分支和标签信息**。
2. 存储在本地: 更新本地仓库中的`.git/fetch-head`文件，记录获取的引用。
3. 不影响工作目录: 不会修改当前分支的文件内容或分支状态。
- `git pull`:
1. 执行 git fetch: 首先获取远程仓库的最新更改。
2. 自动合并: 尝试将远程分支（通常是 origin/main）的最新提交合并到当前分支。
3. 如果没有冲突，工作目录会直接更新为包含远程和本地的所有更改。
4. 如果存在冲突，Git 会提示解决冲突后手动完成合并。

### 理解`git checkout`为什么会有冲突
- 使用`git checkout`命令切换本地分支可能会改变文件。具体来说，`git checkout`用于在不同的分支之间进行切换，并且会将工作目录和暂存区的内容更新为对应分支的状态。
- 以下是一些可能的情况：
1. **切换到现有分支**：如果你从一个分支切换到另一个已经存在的分支，Git 会将工作目录和暂存区的内容更新为该分支的最新状态。如果两个分支之间的文件有冲突，Git 会提示你解决这些冲突。
2. **创建并切换到新分支**：如果你使用`git checkout -b `创建一个新的分支并立即切换到该分支，Git 会在当前分支的基础上创建一个新分支，并将工作目录和暂存区的内容保持不变。
3. **切换到远程分支**：如果你切换到一个本地没有但存在于远程仓库的分支（例如 `origin/main`），Git会首先尝试拉取该分支的最新内容到本地，然后更新工作目录和暂存区。
- 以下是一些常见的`git checkout`命令示例：
```Bash
git checkout master # 切换到名为 master 的分支,并更新文件
git checkout -b # 创建并切换到新分支
git checkout origin/ # 切换到远程分支
```
- 在执行这些命令时，如果**当前工作目录中有未提交的更改，并且这些更改与你要切换的分支有冲突**，Git 会阻止你切换分支并提示你解决这些更改。
- 可以使用`git stash`命令将这些更改暂存起来，以便稍后恢复。
```Bash
git stash # 暂存当前更改
git checkout # 切换分支
git stash pop # 恢复暂存的更改
```


